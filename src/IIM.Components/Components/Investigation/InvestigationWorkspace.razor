
@using IIM.Core.Models
@using IIM.Components.Services
@using IIM.Core.Services
@using IIM.Shared.Enums
@using Microsoft.AspNetCore.SignalR.Client
@inject IInvestigationService InvestigationService
@inject IHubConnectionService HubService
@inject ILogger<InvestigationWorkspace> Logger
@implements IAsyncDisposable

<div class="investigation-workspace">
    <div class="workspace-header">
        @if (Session != null)
        {
            <h3>@Session.Title</h3>
            <div class="session-meta">
                <span class="badge @GetTypeClass(Session.Type)">@Session.Type</span>
                <span class="text-muted">@Session.UpdatedAt.ToString("MMM dd, HH:mm")</span>
            </div>
        }
    </div>

    <div class="chat-container" @ref="chatContainer">
        @if (Messages != null)
        {
            @foreach (var message in Messages)
            {
                <InvestigationMessage Message="@message"
                                      OnToolExecute="@(async (args) => await ExecuteTool(args.toolName, args.parameters))"
                                      OnEvidenceView="@((evidenceId) => ViewEvidence(evidenceId))"
                                      OnCitationClick="@((citation) => ShowCitation(citation))" />
            }
        }

        @if (IsProcessing)
        {
            <div class="processing-indicator">
                <div class="spinner-border spinner-border-sm" role="status"></div>
                <span>@CurrentProcessingStep</span>
            </div>
        }

        @if (!string.IsNullOrEmpty(ErrorMessage))
        {
            <div class="alert alert-danger" role="alert">
                @ErrorMessage
                <button type="button" class="btn-close" @onclick="@(() => ErrorMessage = string.Empty)"></button>
            </div>
        }
    </div>

    <MultiModalInput OnSendMessage="@SendMessage"
                     OnFileAttach="@AttachFile"
                     OnVoiceInput="@ProcessVoiceInput"
                     OnToolSelect="@SelectTool"
                     AvailableTools="@AvailableTools"
                     ActiveModels="@ActiveModels"
                     IsEnabled="@(!IsProcessing)" />
</div>

@code {
    [Parameter] public string? SessionId { get; set; }
    [Parameter] public string? CaseId { get; set; }

    private ElementReference chatContainer;
    private InvestigationSession? Session;
    private List<Core.Models.InvestigationMessage> Messages = new();
    private List<string> AvailableTools = new();
    private Dictionary<string, Core.Models.ModelConfiguration> ActiveModels = new();
    private bool IsProcessing = false;
    private string CurrentProcessingStep = "";
    private string ErrorMessage = "";  // FIX: Added missing field
    private HubConnection? _hubConnection;

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(SessionId))
        {
            await LoadSession(SessionId);
        }
        else if (!string.IsNullOrEmpty(CaseId))
        {
            await CreateNewSession();
        }

        await ConnectToHub();
    }

    private async Task LoadSession(string sessionId)
    {
        Session = await InvestigationService.GetSessionAsync(sessionId);
        if (Session != null)
        {
            Messages = Session.Messages;
            AvailableTools = Session.EnabledTools;
            ActiveModels = Session.Models;
        }
    }

    private async Task CreateNewSession()
    {
        // FIX: Use correct constructor with positional parameters
        Session = await InvestigationService.CreateSessionAsync(
            new CreateSessionRequest(
                CaseId!,  // positional parameter, not named
                "New Investigation",
                InvestigationType.GeneralInquiry.ToString()
            ));
        SessionId = Session.Id;
    }

    private async Task ConnectToHub()
    {
        _hubConnection = await HubService.ConnectAsync("investigationHub");

        _hubConnection.On<Core.Models.InvestigationMessage>("ReceiveMessage", (message) =>
        {
            Messages.Add(message);
            InvokeAsync(StateHasChanged);
            InvokeAsync(ScrollToBottom);
        });

        _hubConnection.On<string>("ProcessingUpdate", (step) =>
        {
            CurrentProcessingStep = step;
            InvokeAsync(StateHasChanged);
        });

        if (SessionId != null)
        {
            await _hubConnection.SendAsync("JoinSession", SessionId);
        }
    }

    private async Task SendMessage(InvestigationQuery query)
    {
        if (Session == null) return;

        IsProcessing = true;
        CurrentProcessingStep = "Analyzing query...";
        ErrorMessage = "";  // Clear any previous errors

        try
        {
            var response = await InvestigationService.ProcessQueryAsync(Session.Id, query);

            // Add user message
            Messages.Add(new Core.Models.InvestigationMessage
            {
                Role = MessageRole.User,
                Content = query.Text,
                Attachments = query.Attachments,
                Timestamp = DateTimeOffset.UtcNow
            });

            // Add assistant response
            Messages.Add(new Core.Models.InvestigationMessage
            {
                Role = MessageRole.Assistant,
                Content = response.Message,
                ToolResults = response.ToolResults,
                Citations = response.Citations,
                Timestamp = DateTimeOffset.UtcNow,
                ModelUsed = ActiveModels.Values.FirstOrDefault()?.ModelId
            });

            await ScrollToBottom();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to send message");
            ErrorMessage = $"Failed to send message: {ex.Message}";
        }
        finally
        {
            IsProcessing = false;
            CurrentProcessingStep = "";
        }
    }

    private async Task ExecuteTool(string toolName, Dictionary<string, object> parameters)
    {
        IsProcessing = true;
        CurrentProcessingStep = $"Running {toolName}...";
        ErrorMessage = "";  // Clear any previous errors

        try
        {
            // Execute the tool and get the result
            var toolResult = await InvestigationService.ExecuteToolAsync(SessionId!, toolName, parameters);

            // Send the result through SignalR if needed
            if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
            {
                await _hubConnection.SendAsync("ToolExecuted", SessionId, toolResult);
            }

            // Update the UI with the tool result
            if (toolResult.Status == ToolStatus.Success)
            {
                // Handle successful execution
                if (toolResult.Visualizations.Any())
                {
                    // Render visualizations
                    foreach (var viz in toolResult.Visualizations)
                    {
                        // Handle visualization rendering
                        Logger.LogInformation("Rendering visualization: {Type} - {Title}", viz.Type, viz.Title);
                    }
                }

                if (toolResult.Recommendations.Any())
                {
                    // Show recommendations to user
                    foreach (var recommendation in toolResult.Recommendations)
                    {
                        Logger.LogInformation("Recommendation: {Recommendation}", recommendation);
                    }
                }
            }
            else if (toolResult.Status == ToolStatus.Failed)
            {
                // Handle failure - FIX: Use ErrorMessage field
                ErrorMessage = toolResult.ErrorMessage ?? "Tool execution failed";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to execute tool {ToolName}", toolName);
            ErrorMessage = $"Failed to execute {toolName}: {ex.Message}";  // FIX: Use ErrorMessage field
        }
        finally
        {
            IsProcessing = false;
            CurrentProcessingStep = "";
            StateHasChanged();
        }
    }

    private async Task AttachFile(List<Attachment> attachments)
    {
        // Handle file attachments
        foreach (var attachment in attachments)
        {
            // Process attachment
            Logger.LogInformation("Processing attachment: {FileName}", attachment.FileName);
        }
        await Task.CompletedTask;
    }

    private async Task ProcessVoiceInput(Stream audioStream)
    {
        IsProcessing = true;
        CurrentProcessingStep = "Transcribing audio...";

        try
        {
            // Process voice input
            Logger.LogInformation("Processing voice input");
            await Task.Delay(1000); // Placeholder for actual processing
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to process voice input");
            ErrorMessage = "Failed to process voice input";
        }
        finally
        {
            IsProcessing = false;
        }
    }

    private async Task SelectTool(string toolId)
    {
        // Handle tool selection
        Logger.LogInformation("Tool selected: {ToolId}", toolId);
        await Task.CompletedTask;
    }

    private void ViewEvidence(string evidenceId)
    {
        // Navigate to evidence viewer
        Logger.LogInformation("Viewing evidence: {EvidenceId}", evidenceId);
    }

    private void ShowCitation(Core.Models.Citation citation)
    {
        // Show citation details
        Logger.LogInformation("Showing citation: {Source}", citation.Source);
    }

    private async Task ScrollToBottom()
    {
        await chatContainer.FocusAsync();
    }

    private string GetTypeClass(InvestigationType type) => type switch
    {
        InvestigationType.EvidenceAnalysis => "badge-primary",
        InvestigationType.OSINTResearch => "badge-info",
        InvestigationType.ForensicAnalysis => "badge-danger",
        _ => "badge-secondary"
    };

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}