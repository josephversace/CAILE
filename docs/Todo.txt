IIM Platform Migration Plan - Complete Documentation
Project Current State
The Intelligent Investigation Machine (IIM) is a Blazor Hybrid desktop application for AI-powered investigations, currently deployed on Framework laptops with 128GB RAM. The codebase has:

IIM.Desktop: Blazor Hybrid UI (currently has all service registrations - wrong)
IIM.Api: ASP.NET Core Minimal API (should have all services but doesn't)
Infrastructure: WSL2, Docker containers (Qdrant, MinIO, embedding service)
Problem: Services are registered in Desktop instead of API, making Desktop fat instead of thin

Target Architecture
Three Deployment Modes (Single Installer):
┌─────────────────────────────────────────────┐
│ Mode 1: Standalone (Single Investigator)     │
│ - Desktop UI + Local API                     │
│ - Everything on one machine                  │
│ - Dynamic model loading                      │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│ Mode 2: Client (Team Member)                 │
│ - Desktop UI only                            │
│ - Connects to central API server             │
│ - No local services                          │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│ Mode 3: Server (Central API)                 │
│ - API only, no UI                            │
│ - Serves multiple investigators              │
│ - Admin web interface for configuration      │
│ - Template-based model management            │
└─────────────────────────────────────────────┘
Key Technical Decisions Made

API Backwards Compatibility: Client 1.2 works with API 1.2+
Configuration: Hybrid approach (appsettings.json bootstrap + database runtime)
Admin Interface: Razor Pages in API project (/admin routes)
Data Isolation: Start with no isolation, design for department-based filtering
Authentication: OpenIddict for OAuth2/OIDC
Real-time Updates: SignalR for notifications
Storage: MinIO for all evidence (even standalone)
Model Management:

Standalone: Dynamic loading
Server: Admin-configured templates



Migration Plan - Phases
Phase 1: Service Migration (Current Focus)
Goal: Move all services from Desktop to API, make Desktop a thin client
Step 1.1: Create API Service Structure ✅ READY TO IMPLEMENT
Create extension methods in API project to organize services:
src/IIM.Api/
├── Extensions/
│   ├── ServiceCollectionExtensions.cs (orchestrator)
│   ├── CoreServiceExtensions.cs (business logic)
│   ├── InfrastructureServiceExtensions.cs (external systems)
│   ├── ApplicationServiceExtensions.cs (app-specific)
│   ├── HttpClientExtensions.cs (HTTP clients)
│   ├── BackgroundServiceExtensions.cs (hosted services)
│   └── MediatRExtensions.cs (command/query handlers)
├── Configuration/
│   ├── DeploymentConfiguration.cs
│   ├── QdrantConfiguration.cs
│   ├── InferenceConfiguration.cs
│   └── ModelTemplateConfiguration.cs
├── Commands/ (MediatR for audit-critical operations)
│   ├── Investigation/
│   ├── Evidence/
│   └── Models/
├── Behaviors/ (MediatR pipeline)
│   ├── AuditBehavior.cs
│   ├── LoggingBehavior.cs
│   └── ValidationBehavior.cs
└── Hubs/ (SignalR)
    ├── InvestigationHub.cs
    └── AdminHub.cs
Step 1.2: Move Services from Desktop to API
Services to move (in order):

HTTP Clients (qdrant, embed, wsl)
Infrastructure (WslManager, QdrantService, EmbeddingService)
Core Services (ModelOrchestrator, InferencePipeline, SessionService)
Application Services (InvestigationService, EvidenceManager, CaseManager)
Background Services (EvidenceIntegrityMonitor, WslServiceOrchestrator)

Step 1.3: Create API Client for Desktop
csharppublic interface IIIMApiClient
{
    // All operations Desktop needs
    Task<InvestigationSession> CreateSessionAsync(...);
    Task<Evidence> IngestEvidenceAsync(...);
    Task<InferenceResult> ProcessQueryAsync(...);
    // etc.
}
Step 1.4: Strip Desktop to Thin Client
Desktop will only have:

Blazor components
IIMApiClient
StateContainer
UI services only

Phase 2: Deployment Mode Support
Step 2.1: Add Deployment Configuration
csharppublic class DeploymentConfiguration
{
    public DeploymentMode Mode { get; set; }
    public bool CanChangeMode { get; set; }
    public string ApiUrl { get; set; }
    public AuthenticationConfig Auth { get; set; }
}
Step 2.2: Implement Mode-Specific Services
csharp// Different implementations based on mode
IModelManager → DynamicModelManager (standalone) | TemplateModelManager (server)
IAuthService → LocalAuthService (standalone) | OpenIddictAuthService (server)
IConfigService → FileConfigService (standalone) | DatabaseConfigService (server)
Step 2.3: Add Admin Web Interface
/admin routes in API:
├── /admin/dashboard
├── /admin/models (template configuration)
├── /admin/users
├── /admin/system
└── /admin/audit
Phase 3: SignalR & Real-time
Step 3.1: Add SignalR Infrastructure

InvestigationHub for session updates
AdminHub for system notifications
Client reconnection logic
Event broadcasting system

Step 3.2: Connect Desktop to SignalR

Auto-connect on startup
Subscribe to relevant channels
Handle disconnections gracefully

Phase 4: Authentication & Authorization
Step 4.1: Implement OpenIddict

OAuth2/OIDC server in API
Support for external providers
Default admin account for setup

Step 4.2: Add Authentication to Desktop

Login flow
Token management
Automatic refresh

Phase 5: Multi-User Preparation
Step 5.1: Design for Data Isolation
Add DepartmentId/TenantId to all entities:
csharppublic class Evidence
{
    public string Id { get; set; }
    public string DepartmentId { get; set; } // For future isolation
    // ... rest of properties
}
Step 5.2: Add Filtering Layer
csharppublic interface IDataFilter
{
    IQueryable<T> ApplyFilter<T>(IQueryable<T> query, UserContext context);
}
Implementation Checklist
Immediate Tasks (This Sprint)

 Run PowerShell script to create API extension structure
 Move service registrations from Desktop to API
 Update API Program.cs to use extension methods
 Create IIMApiClient interface
 Implement HttpClient in Desktop for API calls
 Remove business services from Desktop
 Test standalone mode works
 Add basic SignalR hubs

Next Sprint

 Add deployment mode configuration
 Implement admin Razor pages
 Add model template management
 Implement OpenIddict authentication
 Add mode switching capability
 Test client-server mode

Future Sprints

 Data isolation implementation
 Multi-investigator collaboration
 Advanced audit logging
 Performance optimization
 Backup/restore functionality

Code Patterns to Follow
1. Service Registration Pattern
csharp// Always use interfaces
services.AddSingleton<IServiceName, ImplementationName>();

// Mode-specific registration
services.AddSingleton<IModelManager>(sp =>
{
    var config = sp.GetRequiredService<DeploymentConfiguration>();
    return config.Mode == DeploymentMode.Standalone
        ? new DynamicModelManager(...)
        : new TemplateModelManager(...);
});
2. API Endpoint Pattern
csharp// Audit-critical = MediatR
app.MapPost("/api/evidence/ingest", async (IMediator mediator, IngestEvidenceCommand command) =>
{
    var result = await mediator.Send(command);
    return Results.Ok(result);
});

// Simple operations = Direct service
app.MapGet("/api/status", async (ISystemService service) =>
{
    return Results.Ok(await service.GetStatusAsync());
});
3. Configuration Pattern
csharp// Bootstrap from file
var deploymentMode = configuration["DeploymentMode"];

// Runtime from database/service
var modelTemplate = await configService.GetModelTemplateAsync();
Critical Notes for Implementation

Don't break standalone mode - It must keep working throughout migration
Keep MediatR selective - Only for audit-critical operations
Design for multi-tenancy - Add DepartmentId fields now, implement filtering later
Backward compatibility - API changes must not break older clients
Configuration location - Bootstrap from file, runtime from database

Success Criteria
Phase 1 is complete when:

Desktop only contains UI code
All business logic is in API
Desktop calls API for all operations
Standalone mode works exactly as before
Code is organized with extension methods
SignalR infrastructure is in place

Next LLM Instructions
When continuing this work:

Check current state against this plan
Complete Phase 1 migration first
Use the PowerShell scripts already created
Follow the service registration patterns
Keep MediatR for audit operations only
Test standalone mode after each change
Don't add complexity that isn't needed yet