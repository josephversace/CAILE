# IIM Platform Refactoring - Continuation Prompt (Updated Post-Mediator)

## Project Overview
You are working on the **Intelligent Investigation Machine (IIM)** - a Blazor Hybrid + WSL2 desktop application for law enforcement AI investigations. This is a premium training platform that runs entirely on-premises on Framework PCs with 128GB RAM and AMD GPUs.

## Core Functionality
- Local AI inference using multiple model formats (ONNX, Ollama, LlamaCpp) via plugin architecture
- RAG (Retrieval-Augmented Generation) for evidence analysis  
- Multi-modal support (text, image, audio, video)
- Evidence management with chain of custody
- WSL2 integration running Docker containers (PostgreSQL, Qdrant, Redis, MinIO)
- Model Templates for different investigation types (Fast, Deep Analysis, Multi-Modal)
- **NEW**: Mediator pattern for all operations with automatic logging, validation, caching, and audit trails

## Technology Stack
- .NET 8 with Blazor Hybrid (WebView2)
- Windows Forms host application (net8.0-windows10.0.17763.0)
- Minimal APIs for backend (no MVC Controllers)
- WSL2 with Docker for services
- ONNX Runtime with DirectML/ROCm/CUDA support
- **NEW**: Custom Mediator implementation (no external dependencies)
- **NEW**: Pipeline behaviors for cross-cutting concerns

## Current Solution Structure
```
/src
├── IIM.Shared/          # DTOs, Enums, Common Models (no dependencies)
│   ├── DTOs/           # API request/response contracts
│   ├── Enums/          # Shared enumerations
│   └── Models/         # Simple data structures (TimeRange, FileMetadata, etc.)
│
├── IIM.Infrastructure/  # External services, WSL, Storage (depends on Shared)
│   ├── Platform/       # WSL management, Docker orchestration
│   ├── Storage/        # File system, MinIO integration
│   └── VectorStore/    # Qdrant models and services
│
├── IIM.Plugin.SDK/      # Plugin interfaces (depends on Shared)
│
├── IIM.Core/           # Domain models, business logic (depends on Infrastructure, Plugin.SDK, Shared)
│   ├── Models/         # Domain entities (Case, Evidence, Investigation, etc.)
│   ├── Services/       # Core business services
│   ├── AI/            # AI/ML orchestration
│   ├── Inference/     # Inference pipeline
│   ├── RAG/           # RAG implementation
│   └── Mediator/      # ✅ NEW: Custom mediator implementation
│       ├── IMediator.cs
│       ├── SimpleMediator.cs
│       └── MediatorServiceExtensions.cs
│
├── IIM.Application/    # Application services (depends on Core, Shared)
│   ├── Services/      # High-level orchestration services
│   ├── Interfaces/    # Application-level interfaces
│   ├── Commands/      # ✅ NEW: Command handlers with CQRS pattern
│   │   ├── Wsl/
│   │   │   ├── EnsureWslCommand.cs
│   │   │   ├── EnsureWslCommandHandler.cs
│   │   │   └── WslNotifications.cs
│   │   ├── Models/
│   │   │   ├── LoadModelCommand.cs
│   │   │   ├── LoadModelCommandHandler.cs
│   │   │   ├── UnloadModelCommand.cs
│   │   │   ├── UnloadModelCommandHandler.cs
│   │   │   └── ModelNotifications.cs
│   │   └── Investigation/
│   │       ├── ProcessInvestigationCommand.cs
│   │       ├── ProcessInvestigationCommandHandler.cs
│   │       ├── CreateSessionCommand.cs
│   │       ├── CreateSessionCommandHandler.cs
│   │       └── InvestigationNotifications.cs
│   ├── Queries/       # ✅ NEW: Query handlers for read operations
│   │   ├── SearchDocumentsQuery.cs
│   │   └── SearchDocumentsQueryHandler.cs
│   ├── Behaviors/     # ✅ NEW: Pipeline behaviors
│   │   ├── LoggingBehavior.cs
│   │   ├── ValidationBehavior.cs
│   │   ├── PerformanceBehavior.cs
│   │   ├── CachingBehavior.cs
│   │   ├── RetryBehavior.cs
│   │   ├── TransactionBehavior.cs
│   │   └── AuditBehavior.cs
│   └── Handlers/      # ✅ NEW: Notification handlers
│       ├── NotificationHandlers.cs
│       └── AdditionalNotificationHandlers.cs
│
├── IIM.Api/           # HTTP endpoints, Minimal APIs (depends on Core, Shared)
│   ├── Program.cs     # All endpoints defined here (no Controllers)
│   └── Endpoints/     # Organized endpoint groups
│
├── IIM.Components/    # Blazor UI components (depends on Application, Core, Infrastructure, Shared)
│   └── [UI Components]
│
└── IIM.Desktop/       # Windows Forms host (depends on all)
    └── Program.cs     # ✅ UPDATED: Mediator configuration added

/tests
├── IIM.Core.Tests/
├── IIM.Application.Tests/    # ✅ NEW: Tests for commands/queries
├── IIM.Api.Tests/
└── IIM.Integration.Tests/
```

## ✅ Refactoring Completed

### Phase 1-3: Foundation (COMPLETE)
- ✅ Removed empty Controller classes - Using only Minimal APIs
- ✅ Fixed circular dependencies - ISessionProvider removed, using ISessionService
- ✅ Fixed namespace conflicts and model organization
- ✅ All projects compile without errors
- ✅ Mock implementations allow the app to start

### Phase 4: Service Implementation (COMPLETE)
- ✅ InvestigationService fully implemented with correct model properties
- ✅ ModelOrchestrator has real implementation (needs actual model loading)
- ✅ Export services properly wired with correct method signatures
- ✅ All required service interfaces properly registered in DI

### Phase 5: Mediator Pattern (COMPLETE) 🎉
- ✅ Custom mediator implementation without external dependencies
- ✅ Command/Query handlers for all major operations
- ✅ 7 Pipeline behaviors for cross-cutting concerns:
  - Logging (all requests/responses logged)
  - Validation (input validation)
  - Performance monitoring (slow operation warnings)
  - Caching (automatic query result caching)
  - Retry (exponential backoff for transient failures)
  - Transactions (commands wrapped in transactions)
  - Audit (compliance logging)
- ✅ Notification system for decoupled event handling
- ✅ All handlers use correct model properties
- ✅ Full integration with existing services

## 🎯 Current State Assessment

### What's Working:
- ✅ All projects compile and build successfully
- ✅ Mediator pattern fully integrated
- ✅ Commands/Queries replace direct service calls
- ✅ Automatic cross-cutting concerns via pipeline behaviors
- ✅ Clean separation between read (Query) and write (Command) operations
- ✅ Event-driven notifications for decoupled components
- ✅ Mock implementations allow testing without WSL/Docker

### What's Ready for Implementation:

#### Priority 1: WSL2 Integration (CRITICAL - Blocks Real Usage)
**Status**: Command structure ready, needs actual implementation
```csharp
// Command exists and compiles:
await _mediator.Send(new EnsureWslCommand { AutoInstall = true });
// TODO: Implement actual WSL detection/installation in WslManager
```

#### Priority 2: Model Loading (HIGH)
**Status**: Command structure ready, needs actual ONNX/Ollama integration
```csharp
// Command exists and compiles:
await _mediator.Send(new LoadModelCommand { ModelId = "llama3.1" });
// TODO: Implement actual model download and loading
```

#### Priority 3: RAG Pipeline (HIGH)
**Status**: Query structure ready, needs actual vector store integration
```csharp
// Query exists and compiles:
await _mediator.Send(new SearchDocumentsQuery { Query = "evidence" });
// TODO: Connect to real Qdrant instance
```

## 📋 Next Implementation Priorities

### Sprint 1: WSL2 & Docker (Week 1)
**Goal**: Get WSL2 running with all required services

1. **Implement `WslManager.IsWslEnabled()`**
   - Check Windows features
   - Verify WSL2 installation
   - Return accurate status

2. **Implement `WslManager.EnableWsl()`**
   - Enable required Windows features
   - Install WSL2 kernel update
   - Set WSL2 as default

3. **Implement Docker container management**
   - Start Qdrant container
   - Start embedding service
   - Start Ollama service
   - Verify health endpoints

**Test Command**:
```csharp
var result = await _mediator.Send(new EnsureWslCommand());
// Should return Unit.Value on success
```

### Sprint 2: Model Management (Week 2)
**Goal**: Load and run actual AI models

1. **Implement ONNX model loading**
   - Download models from Hugging Face
   - Load into ONNX Runtime
   - Implement DirectML/ROCm execution

2. **Implement Ollama integration**
   - Connect to Ollama API
   - Pull models (llama3.1, mistral, etc.)
   - Implement streaming inference

3. **Add model caching**
   - Local model storage
   - Version management
   - Automatic updates

**Test Command**:
```csharp
var handle = await _mediator.Send(new LoadModelCommand 
{
    ModelId = "llama3.1:70b",
    Provider = "Ollama"
});
// Should return ModelHandle with valid session
```

### Sprint 3: RAG Implementation (Week 3)
**Goal**: Full document search with citations

1. **Implement document ingestion**
   - PDF/DOCX parsing
   - Text chunking strategies
   - Metadata extraction

2. **Connect Qdrant vector store**
   - Create collections
   - Generate embeddings
   - Store with metadata

3. **Implement semantic search**
   - Query embedding generation
   - Vector similarity search
   - Result reranking

**Test Query**:
```csharp
var results = await _mediator.Send(new SearchDocumentsQuery 
{
    Query = "financial transactions",
    TopK = 10
});
// Should return relevant documents with citations
```

### Sprint 4: Multi-Modal Pipeline (Week 4)
**Goal**: Audio/Image analysis working

1. **Whisper integration**
   - Audio file processing
   - Transcription with timestamps
   - Language detection

2. **CLIP integration**
   - Image embedding generation
   - Visual similarity search
   - Object detection

3. **Pipeline orchestration**
   - Multi-modal queries
   - Cross-modal search
   - Result fusion

## 🧪 Testing Strategy

### Unit Tests (using Mediator)
```csharp
[Fact]
public async Task Should_Load_Model_Successfully()
{
    // Arrange
    var mediator = new ServiceCollection()
        .AddSimpleMediator()
        .AddLogging()
        .BuildServiceProvider()
        .GetRequiredService<IMediator>();
    
    // Act
    var result = await mediator.Send(new LoadModelCommand 
    {
        ModelId = "test-model"
    });
    
    // Assert
    result.Should().NotBeNull();
    result.ModelId.Should().Be("test-model");
}
```

### Integration Tests
```csharp
[Fact]
[Trait("Category", "Integration")]
public async Task Full_Investigation_Workflow()
{
    // Initialize system
    await _mediator.Send(new EnsureWslCommand());
    
    // Load models
    await _mediator.Send(new LoadModelCommand { ModelId = "llama3.1" });
    
    // Create session
    var session = await _mediator.Send(new CreateSessionCommand 
    {
        CaseId = "test-case"
    });
    
    // Process query
    var response = await _mediator.Send(new ProcessInvestigationCommand 
    {
        SessionId = session.Id,
        Query = "Analyze evidence"
    });
    
    response.Should().NotBeNull();
}
```

## 🔧 Development Workflow

### Adding New Features (Post-Mediator)

1. **Define Command/Query**
```csharp
public class YourCommand : IRequest<YourResponse>
{
    // Properties
}
```

2. **Create Handler**
```csharp
public class YourCommandHandler : IRequestHandler<YourCommand, YourResponse>
{
    public async Task<YourResponse> Handle(YourCommand request, CancellationToken ct)
    {
        // Implementation
    }
}
```

3. **Use via Mediator**
```csharp
var result = await _mediator.Send(new YourCommand());
```

## 🎯 Success Metrics

The platform will be production-ready when:
- ✅ Mediator pattern fully integrated (DONE)
- ⏳ WSL2 and Docker containers auto-start
- ⏳ At least 3 AI models load and run
- ⏳ Document ingestion and RAG search functional
- ⏳ Multi-modal analysis operational
- ⏳ All mock implementations replaced with real ones
- ⏳ Test coverage > 80% for critical paths
- ⏳ Performance: <3s model load, <500ms inference

## 💡 Key Architectural Decisions

1. **Mediator Pattern**: Provides consistent handling of all operations with automatic logging, validation, and caching
2. **CQRS Separation**: Commands modify state, Queries read state - clear separation of concerns
3. **Pipeline Behaviors**: Cross-cutting concerns handled in one place
4. **Event-Driven**: Notifications allow decoupled components to react to events

## 🚀 Quick Start for New Developers

```csharp
// 1. Initialize the system
await _mediator.Send(new EnsureWslCommand());

// 2. Load a model
await _mediator.Send(new LoadModelCommand 
{ 
    ModelId = "llama3.1:70b" 
});

// 3. Process a query
var response = await _mediator.Send(new ProcessInvestigationCommand 
{
    SessionId = sessionId,
    Query = "Your investigation query"
});
```

## 📝 Notes

- All operations now go through the mediator for consistency
- Pipeline behaviors ensure enterprise-grade features on every operation
- Mock implementations remain for development without WSL/Docker
- Focus is now on implementing the actual service logic behind the commands